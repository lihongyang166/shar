// Code generated by mockery v2.43.1. DO NOT EDIT.

package workflow

import (
	context "context"

	common "gitlab.com/shar-workflow/shar/common"

	mock "github.com/stretchr/testify/mock"

	model "gitlab.com/shar-workflow/shar/model"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"

	slog "log/slog"
)

// MockOps is an autogenerated mock type for the Ops type
type MockOps struct {
	mock.Mock
}

type MockOps_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOps) EXPECT() *MockOps_Expecter {
	return &MockOps_Expecter{mock: &_m.Mock}
}

// CancelProcessInstance provides a mock function with given fields: ctx, state
func (_m *MockOps) CancelProcessInstance(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for CancelProcessInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CancelProcessInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelProcessInstance'
type MockOps_CancelProcessInstance_Call struct {
	*mock.Call
}

// CancelProcessInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) CancelProcessInstance(ctx interface{}, state interface{}) *MockOps_CancelProcessInstance_Call {
	return &MockOps_CancelProcessInstance_Call{Call: _e.mock.On("CancelProcessInstance", ctx, state)}
}

func (_c *MockOps_CancelProcessInstance_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_CancelProcessInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_CancelProcessInstance_Call) Return(_a0 error) *MockOps_CancelProcessInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CancelProcessInstance_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_CancelProcessInstance_Call {
	_c.Call.Return(run)
	return _c
}

// CheckProcessTaskDeprecation provides a mock function with given fields: ctx, workflow, processId
func (_m *MockOps) CheckProcessTaskDeprecation(ctx context.Context, workflow *model.Workflow, processId string) error {
	ret := _m.Called(ctx, workflow, processId)

	if len(ret) == 0 {
		panic("no return value specified for CheckProcessTaskDeprecation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow, string) error); ok {
		r0 = rf(ctx, workflow, processId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CheckProcessTaskDeprecation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckProcessTaskDeprecation'
type MockOps_CheckProcessTaskDeprecation_Call struct {
	*mock.Call
}

// CheckProcessTaskDeprecation is a helper method to define mock.On call
//   - ctx context.Context
//   - workflow *model.Workflow
//   - processId string
func (_e *MockOps_Expecter) CheckProcessTaskDeprecation(ctx interface{}, workflow interface{}, processId interface{}) *MockOps_CheckProcessTaskDeprecation_Call {
	return &MockOps_CheckProcessTaskDeprecation_Call{Call: _e.mock.On("CheckProcessTaskDeprecation", ctx, workflow, processId)}
}

func (_c *MockOps_CheckProcessTaskDeprecation_Call) Run(run func(ctx context.Context, workflow *model.Workflow, processId string)) *MockOps_CheckProcessTaskDeprecation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Workflow), args[2].(string))
	})
	return _c
}

func (_c *MockOps_CheckProcessTaskDeprecation_Call) Return(_a0 error) *MockOps_CheckProcessTaskDeprecation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CheckProcessTaskDeprecation_Call) RunAndReturn(run func(context.Context, *model.Workflow, string) error) *MockOps_CheckProcessTaskDeprecation_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteManualTask provides a mock function with given fields: ctx, job, newvars
func (_m *MockOps) CompleteManualTask(ctx context.Context, job *model.WorkflowState, newvars []byte) error {
	ret := _m.Called(ctx, job, newvars)

	if len(ret) == 0 {
		panic("no return value specified for CompleteManualTask")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, []byte) error); ok {
		r0 = rf(ctx, job, newvars)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CompleteManualTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteManualTask'
type MockOps_CompleteManualTask_Call struct {
	*mock.Call
}

// CompleteManualTask is a helper method to define mock.On call
//   - ctx context.Context
//   - job *model.WorkflowState
//   - newvars []byte
func (_e *MockOps_Expecter) CompleteManualTask(ctx interface{}, job interface{}, newvars interface{}) *MockOps_CompleteManualTask_Call {
	return &MockOps_CompleteManualTask_Call{Call: _e.mock.On("CompleteManualTask", ctx, job, newvars)}
}

func (_c *MockOps_CompleteManualTask_Call) Run(run func(ctx context.Context, job *model.WorkflowState, newvars []byte)) *MockOps_CompleteManualTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].([]byte))
	})
	return _c
}

func (_c *MockOps_CompleteManualTask_Call) Return(_a0 error) *MockOps_CompleteManualTask_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CompleteManualTask_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, []byte) error) *MockOps_CompleteManualTask_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteSendMessageTask provides a mock function with given fields: ctx, job, newvars
func (_m *MockOps) CompleteSendMessageTask(ctx context.Context, job *model.WorkflowState, newvars []byte) error {
	ret := _m.Called(ctx, job, newvars)

	if len(ret) == 0 {
		panic("no return value specified for CompleteSendMessageTask")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, []byte) error); ok {
		r0 = rf(ctx, job, newvars)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CompleteSendMessageTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteSendMessageTask'
type MockOps_CompleteSendMessageTask_Call struct {
	*mock.Call
}

// CompleteSendMessageTask is a helper method to define mock.On call
//   - ctx context.Context
//   - job *model.WorkflowState
//   - newvars []byte
func (_e *MockOps_Expecter) CompleteSendMessageTask(ctx interface{}, job interface{}, newvars interface{}) *MockOps_CompleteSendMessageTask_Call {
	return &MockOps_CompleteSendMessageTask_Call{Call: _e.mock.On("CompleteSendMessageTask", ctx, job, newvars)}
}

func (_c *MockOps_CompleteSendMessageTask_Call) Run(run func(ctx context.Context, job *model.WorkflowState, newvars []byte)) *MockOps_CompleteSendMessageTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].([]byte))
	})
	return _c
}

func (_c *MockOps_CompleteSendMessageTask_Call) Return(_a0 error) *MockOps_CompleteSendMessageTask_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CompleteSendMessageTask_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, []byte) error) *MockOps_CompleteSendMessageTask_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteServiceTask provides a mock function with given fields: ctx, job, newvars
func (_m *MockOps) CompleteServiceTask(ctx context.Context, job *model.WorkflowState, newvars []byte) error {
	ret := _m.Called(ctx, job, newvars)

	if len(ret) == 0 {
		panic("no return value specified for CompleteServiceTask")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, []byte) error); ok {
		r0 = rf(ctx, job, newvars)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CompleteServiceTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteServiceTask'
type MockOps_CompleteServiceTask_Call struct {
	*mock.Call
}

// CompleteServiceTask is a helper method to define mock.On call
//   - ctx context.Context
//   - job *model.WorkflowState
//   - newvars []byte
func (_e *MockOps_Expecter) CompleteServiceTask(ctx interface{}, job interface{}, newvars interface{}) *MockOps_CompleteServiceTask_Call {
	return &MockOps_CompleteServiceTask_Call{Call: _e.mock.On("CompleteServiceTask", ctx, job, newvars)}
}

func (_c *MockOps_CompleteServiceTask_Call) Run(run func(ctx context.Context, job *model.WorkflowState, newvars []byte)) *MockOps_CompleteServiceTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].([]byte))
	})
	return _c
}

func (_c *MockOps_CompleteServiceTask_Call) Return(_a0 error) *MockOps_CompleteServiceTask_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CompleteServiceTask_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, []byte) error) *MockOps_CompleteServiceTask_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteUserTask provides a mock function with given fields: ctx, job, newvars
func (_m *MockOps) CompleteUserTask(ctx context.Context, job *model.WorkflowState, newvars []byte) error {
	ret := _m.Called(ctx, job, newvars)

	if len(ret) == 0 {
		panic("no return value specified for CompleteUserTask")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, []byte) error); ok {
		r0 = rf(ctx, job, newvars)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_CompleteUserTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteUserTask'
type MockOps_CompleteUserTask_Call struct {
	*mock.Call
}

// CompleteUserTask is a helper method to define mock.On call
//   - ctx context.Context
//   - job *model.WorkflowState
//   - newvars []byte
func (_e *MockOps_Expecter) CompleteUserTask(ctx interface{}, job interface{}, newvars interface{}) *MockOps_CompleteUserTask_Call {
	return &MockOps_CompleteUserTask_Call{Call: _e.mock.On("CompleteUserTask", ctx, job, newvars)}
}

func (_c *MockOps_CompleteUserTask_Call) Run(run func(ctx context.Context, job *model.WorkflowState, newvars []byte)) *MockOps_CompleteUserTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].([]byte))
	})
	return _c
}

func (_c *MockOps_CompleteUserTask_Call) Return(_a0 error) *MockOps_CompleteUserTask_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_CompleteUserTask_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, []byte) error) *MockOps_CompleteUserTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateExecution provides a mock function with given fields: ctx, execution
func (_m *MockOps) CreateExecution(ctx context.Context, execution *model.Execution) (*model.Execution, error) {
	ret := _m.Called(ctx, execution)

	if len(ret) == 0 {
		panic("no return value specified for CreateExecution")
	}

	var r0 *model.Execution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Execution) (*model.Execution, error)); ok {
		return rf(ctx, execution)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.Execution) *model.Execution); ok {
		r0 = rf(ctx, execution)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Execution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.Execution) error); ok {
		r1 = rf(ctx, execution)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_CreateExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExecution'
type MockOps_CreateExecution_Call struct {
	*mock.Call
}

// CreateExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - execution *model.Execution
func (_e *MockOps_Expecter) CreateExecution(ctx interface{}, execution interface{}) *MockOps_CreateExecution_Call {
	return &MockOps_CreateExecution_Call{Call: _e.mock.On("CreateExecution", ctx, execution)}
}

func (_c *MockOps_CreateExecution_Call) Run(run func(ctx context.Context, execution *model.Execution)) *MockOps_CreateExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Execution))
	})
	return _c
}

func (_c *MockOps_CreateExecution_Call) Return(_a0 *model.Execution, _a1 error) *MockOps_CreateExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_CreateExecution_Call) RunAndReturn(run func(context.Context, *model.Execution) (*model.Execution, error)) *MockOps_CreateExecution_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJob provides a mock function with given fields: ctx, job
func (_m *MockOps) CreateJob(ctx context.Context, job *model.WorkflowState) (string, error) {
	ret := _m.Called(ctx, job)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) (string, error)); ok {
		return rf(ctx, job)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) string); ok {
		r0 = rf(ctx, job)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.WorkflowState) error); ok {
		r1 = rf(ctx, job)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type MockOps_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - job *model.WorkflowState
func (_e *MockOps_Expecter) CreateJob(ctx interface{}, job interface{}) *MockOps_CreateJob_Call {
	return &MockOps_CreateJob_Call{Call: _e.mock.On("CreateJob", ctx, job)}
}

func (_c *MockOps_CreateJob_Call) Run(run func(ctx context.Context, job *model.WorkflowState)) *MockOps_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_CreateJob_Call) Return(_a0 string, _a1 error) *MockOps_CreateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_CreateJob_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) (string, error)) *MockOps_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProcessInstance provides a mock function with given fields: ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers
func (_m *MockOps) CreateProcessInstance(ctx context.Context, executionId string, parentProcessID string, parentElementID string, processId string, workflowName string, workflowId string, headers []byte) (*model.ProcessInstance, error) {
	ret := _m.Called(ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers)

	if len(ret) == 0 {
		panic("no return value specified for CreateProcessInstance")
	}

	var r0 *model.ProcessInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, []byte) (*model.ProcessInstance, error)); ok {
		return rf(ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, []byte) *model.ProcessInstance); ok {
		r0 = rf(ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string, []byte) error); ok {
		r1 = rf(ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_CreateProcessInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProcessInstance'
type MockOps_CreateProcessInstance_Call struct {
	*mock.Call
}

// CreateProcessInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - executionId string
//   - parentProcessID string
//   - parentElementID string
//   - processId string
//   - workflowName string
//   - workflowId string
//   - headers []byte
func (_e *MockOps_Expecter) CreateProcessInstance(ctx interface{}, executionId interface{}, parentProcessID interface{}, parentElementID interface{}, processId interface{}, workflowName interface{}, workflowId interface{}, headers interface{}) *MockOps_CreateProcessInstance_Call {
	return &MockOps_CreateProcessInstance_Call{Call: _e.mock.On("CreateProcessInstance", ctx, executionId, parentProcessID, parentElementID, processId, workflowName, workflowId, headers)}
}

func (_c *MockOps_CreateProcessInstance_Call) Run(run func(ctx context.Context, executionId string, parentProcessID string, parentElementID string, processId string, workflowName string, workflowId string, headers []byte)) *MockOps_CreateProcessInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(string), args[6].(string), args[7].([]byte))
	})
	return _c
}

func (_c *MockOps_CreateProcessInstance_Call) Return(_a0 *model.ProcessInstance, _a1 error) *MockOps_CreateProcessInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_CreateProcessInstance_Call) RunAndReturn(run func(context.Context, string, string, string, string, string, string, []byte) (*model.ProcessInstance, error)) *MockOps_CreateProcessInstance_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFatalError provides a mock function with given fields: ctx, state
func (_m *MockOps) DeleteFatalError(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFatalError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_DeleteFatalError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFatalError'
type MockOps_DeleteFatalError_Call struct {
	*mock.Call
}

// DeleteFatalError is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) DeleteFatalError(ctx interface{}, state interface{}) *MockOps_DeleteFatalError_Call {
	return &MockOps_DeleteFatalError_Call{Call: _e.mock.On("DeleteFatalError", ctx, state)}
}

func (_c *MockOps_DeleteFatalError_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_DeleteFatalError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_DeleteFatalError_Call) Return(_a0 error) *MockOps_DeleteFatalError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_DeleteFatalError_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_DeleteFatalError_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJob provides a mock function with given fields: ctx, trackingID
func (_m *MockOps) DeleteJob(ctx context.Context, trackingID string) error {
	ret := _m.Called(ctx, trackingID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, trackingID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_DeleteJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJob'
type MockOps_DeleteJob_Call struct {
	*mock.Call
}

// DeleteJob is a helper method to define mock.On call
//   - ctx context.Context
//   - trackingID string
func (_e *MockOps_Expecter) DeleteJob(ctx interface{}, trackingID interface{}) *MockOps_DeleteJob_Call {
	return &MockOps_DeleteJob_Call{Call: _e.mock.On("DeleteJob", ctx, trackingID)}
}

func (_c *MockOps_DeleteJob_Call) Run(run func(ctx context.Context, trackingID string)) *MockOps_DeleteJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_DeleteJob_Call) Return(_a0 error) *MockOps_DeleteJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_DeleteJob_Call) RunAndReturn(run func(context.Context, string) error) *MockOps_DeleteJob_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNamespace provides a mock function with given fields: ctx, ns
func (_m *MockOps) DeleteNamespace(ctx context.Context, ns string) error {
	ret := _m.Called(ctx, ns)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNamespace")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, ns)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_DeleteNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNamespace'
type MockOps_DeleteNamespace_Call struct {
	*mock.Call
}

// DeleteNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - ns string
func (_e *MockOps_Expecter) DeleteNamespace(ctx interface{}, ns interface{}) *MockOps_DeleteNamespace_Call {
	return &MockOps_DeleteNamespace_Call{Call: _e.mock.On("DeleteNamespace", ctx, ns)}
}

func (_c *MockOps_DeleteNamespace_Call) Run(run func(ctx context.Context, ns string)) *MockOps_DeleteNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_DeleteNamespace_Call) Return(_a0 error) *MockOps_DeleteNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_DeleteNamespace_Call) RunAndReturn(run func(context.Context, string) error) *MockOps_DeleteNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// DeprecateTaskSpec provides a mock function with given fields: ctx, uid
func (_m *MockOps) DeprecateTaskSpec(ctx context.Context, uid []string) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for DeprecateTaskSpec")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_DeprecateTaskSpec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeprecateTaskSpec'
type MockOps_DeprecateTaskSpec_Call struct {
	*mock.Call
}

// DeprecateTaskSpec is a helper method to define mock.On call
//   - ctx context.Context
//   - uid []string
func (_e *MockOps_Expecter) DeprecateTaskSpec(ctx interface{}, uid interface{}) *MockOps_DeprecateTaskSpec_Call {
	return &MockOps_DeprecateTaskSpec_Call{Call: _e.mock.On("DeprecateTaskSpec", ctx, uid)}
}

func (_c *MockOps_DeprecateTaskSpec_Call) Run(run func(ctx context.Context, uid []string)) *MockOps_DeprecateTaskSpec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockOps_DeprecateTaskSpec_Call) Return(_a0 error) *MockOps_DeprecateTaskSpec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_DeprecateTaskSpec_Call) RunAndReturn(run func(context.Context, []string) error) *MockOps_DeprecateTaskSpec_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyProcessInstance provides a mock function with given fields: ctx, state, processInstanceId, executionId
func (_m *MockOps) DestroyProcessInstance(ctx context.Context, state *model.WorkflowState, processInstanceId string, executionId string) error {
	ret := _m.Called(ctx, state, processInstanceId, executionId)

	if len(ret) == 0 {
		panic("no return value specified for DestroyProcessInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, string, string) error); ok {
		r0 = rf(ctx, state, processInstanceId, executionId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_DestroyProcessInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyProcessInstance'
type MockOps_DestroyProcessInstance_Call struct {
	*mock.Call
}

// DestroyProcessInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
//   - processInstanceId string
//   - executionId string
func (_e *MockOps_Expecter) DestroyProcessInstance(ctx interface{}, state interface{}, processInstanceId interface{}, executionId interface{}) *MockOps_DestroyProcessInstance_Call {
	return &MockOps_DestroyProcessInstance_Call{Call: _e.mock.On("DestroyProcessInstance", ctx, state, processInstanceId, executionId)}
}

func (_c *MockOps_DestroyProcessInstance_Call) Run(run func(ctx context.Context, state *model.WorkflowState, processInstanceId string, executionId string)) *MockOps_DestroyProcessInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockOps_DestroyProcessInstance_Call) Return(_a0 error) *MockOps_DestroyProcessInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_DestroyProcessInstance_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, string, string) error) *MockOps_DestroyProcessInstance_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureServiceTaskConsumer provides a mock function with given fields: ctx, uid
func (_m *MockOps) EnsureServiceTaskConsumer(ctx context.Context, uid string) error {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for EnsureServiceTaskConsumer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_EnsureServiceTaskConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureServiceTaskConsumer'
type MockOps_EnsureServiceTaskConsumer_Call struct {
	*mock.Call
}

// EnsureServiceTaskConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
func (_e *MockOps_Expecter) EnsureServiceTaskConsumer(ctx interface{}, uid interface{}) *MockOps_EnsureServiceTaskConsumer_Call {
	return &MockOps_EnsureServiceTaskConsumer_Call{Call: _e.mock.On("EnsureServiceTaskConsumer", ctx, uid)}
}

func (_c *MockOps_EnsureServiceTaskConsumer_Call) Run(run func(ctx context.Context, uid string)) *MockOps_EnsureServiceTaskConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_EnsureServiceTaskConsumer_Call) Return(_a0 error) *MockOps_EnsureServiceTaskConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_EnsureServiceTaskConsumer_Call) RunAndReturn(run func(context.Context, string) error) *MockOps_EnsureServiceTaskConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveEntries provides a mock function with given fields: ctx, processInstanceID, result, errs
func (_m *MockOps) GetActiveEntries(ctx context.Context, processInstanceID string, result chan<- *model.ProcessHistoryEntry, errs chan<- error) {
	_m.Called(ctx, processInstanceID, result, errs)
}

// MockOps_GetActiveEntries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveEntries'
type MockOps_GetActiveEntries_Call struct {
	*mock.Call
}

// GetActiveEntries is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceID string
//   - result chan<- *model.ProcessHistoryEntry
//   - errs chan<- error
func (_e *MockOps_Expecter) GetActiveEntries(ctx interface{}, processInstanceID interface{}, result interface{}, errs interface{}) *MockOps_GetActiveEntries_Call {
	return &MockOps_GetActiveEntries_Call{Call: _e.mock.On("GetActiveEntries", ctx, processInstanceID, result, errs)}
}

func (_c *MockOps_GetActiveEntries_Call) Run(run func(ctx context.Context, processInstanceID string, result chan<- *model.ProcessHistoryEntry, errs chan<- error)) *MockOps_GetActiveEntries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(chan<- *model.ProcessHistoryEntry), args[3].(chan<- error))
	})
	return _c
}

func (_c *MockOps_GetActiveEntries_Call) Return() *MockOps_GetActiveEntries_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_GetActiveEntries_Call) RunAndReturn(run func(context.Context, string, chan<- *model.ProcessHistoryEntry, chan<- error)) *MockOps_GetActiveEntries_Call {
	_c.Call.Return(run)
	return _c
}

// GetCompensationInputVariables provides a mock function with given fields: ctx, processInstanceId, trackingId
func (_m *MockOps) GetCompensationInputVariables(ctx context.Context, processInstanceId string, trackingId string) ([]byte, error) {
	ret := _m.Called(ctx, processInstanceId, trackingId)

	if len(ret) == 0 {
		panic("no return value specified for GetCompensationInputVariables")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]byte, error)); ok {
		return rf(ctx, processInstanceId, trackingId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []byte); ok {
		r0 = rf(ctx, processInstanceId, trackingId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, processInstanceId, trackingId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetCompensationInputVariables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCompensationInputVariables'
type MockOps_GetCompensationInputVariables_Call struct {
	*mock.Call
}

// GetCompensationInputVariables is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceId string
//   - trackingId string
func (_e *MockOps_Expecter) GetCompensationInputVariables(ctx interface{}, processInstanceId interface{}, trackingId interface{}) *MockOps_GetCompensationInputVariables_Call {
	return &MockOps_GetCompensationInputVariables_Call{Call: _e.mock.On("GetCompensationInputVariables", ctx, processInstanceId, trackingId)}
}

func (_c *MockOps_GetCompensationInputVariables_Call) Run(run func(ctx context.Context, processInstanceId string, trackingId string)) *MockOps_GetCompensationInputVariables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockOps_GetCompensationInputVariables_Call) Return(_a0 []byte, _a1 error) *MockOps_GetCompensationInputVariables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetCompensationInputVariables_Call) RunAndReturn(run func(context.Context, string, string) ([]byte, error)) *MockOps_GetCompensationInputVariables_Call {
	_c.Call.Return(run)
	return _c
}

// GetCompensationOutputVariables provides a mock function with given fields: ctx, processInstanceId, trackingId
func (_m *MockOps) GetCompensationOutputVariables(ctx context.Context, processInstanceId string, trackingId string) ([]byte, error) {
	ret := _m.Called(ctx, processInstanceId, trackingId)

	if len(ret) == 0 {
		panic("no return value specified for GetCompensationOutputVariables")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]byte, error)); ok {
		return rf(ctx, processInstanceId, trackingId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []byte); ok {
		r0 = rf(ctx, processInstanceId, trackingId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, processInstanceId, trackingId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetCompensationOutputVariables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCompensationOutputVariables'
type MockOps_GetCompensationOutputVariables_Call struct {
	*mock.Call
}

// GetCompensationOutputVariables is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceId string
//   - trackingId string
func (_e *MockOps_Expecter) GetCompensationOutputVariables(ctx interface{}, processInstanceId interface{}, trackingId interface{}) *MockOps_GetCompensationOutputVariables_Call {
	return &MockOps_GetCompensationOutputVariables_Call{Call: _e.mock.On("GetCompensationOutputVariables", ctx, processInstanceId, trackingId)}
}

func (_c *MockOps_GetCompensationOutputVariables_Call) Run(run func(ctx context.Context, processInstanceId string, trackingId string)) *MockOps_GetCompensationOutputVariables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockOps_GetCompensationOutputVariables_Call) Return(_a0 []byte, _a1 error) *MockOps_GetCompensationOutputVariables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetCompensationOutputVariables_Call) RunAndReturn(run func(context.Context, string, string) ([]byte, error)) *MockOps_GetCompensationOutputVariables_Call {
	_c.Call.Return(run)
	return _c
}

// GetElement provides a mock function with given fields: ctx, state
func (_m *MockOps) GetElement(ctx context.Context, state *model.WorkflowState) (*model.Element, error) {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for GetElement")
	}

	var r0 *model.Element
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) (*model.Element, error)); ok {
		return rf(ctx, state)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) *model.Element); ok {
		r0 = rf(ctx, state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Element)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.WorkflowState) error); ok {
		r1 = rf(ctx, state)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetElement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetElement'
type MockOps_GetElement_Call struct {
	*mock.Call
}

// GetElement is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) GetElement(ctx interface{}, state interface{}) *MockOps_GetElement_Call {
	return &MockOps_GetElement_Call{Call: _e.mock.On("GetElement", ctx, state)}
}

func (_c *MockOps_GetElement_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_GetElement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_GetElement_Call) Return(_a0 *model.Element, _a1 error) *MockOps_GetElement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetElement_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) (*model.Element, error)) *MockOps_GetElement_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutableWorkflowIds provides a mock function with given fields: ctx
func (_m *MockOps) GetExecutableWorkflowIds(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetExecutableWorkflowIds")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetExecutableWorkflowIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutableWorkflowIds'
type MockOps_GetExecutableWorkflowIds_Call struct {
	*mock.Call
}

// GetExecutableWorkflowIds is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockOps_Expecter) GetExecutableWorkflowIds(ctx interface{}) *MockOps_GetExecutableWorkflowIds_Call {
	return &MockOps_GetExecutableWorkflowIds_Call{Call: _e.mock.On("GetExecutableWorkflowIds", ctx)}
}

func (_c *MockOps_GetExecutableWorkflowIds_Call) Run(run func(ctx context.Context)) *MockOps_GetExecutableWorkflowIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockOps_GetExecutableWorkflowIds_Call) Return(_a0 []string, _a1 error) *MockOps_GetExecutableWorkflowIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetExecutableWorkflowIds_Call) RunAndReturn(run func(context.Context) ([]string, error)) *MockOps_GetExecutableWorkflowIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecution provides a mock function with given fields: ctx, executionID
func (_m *MockOps) GetExecution(ctx context.Context, executionID string) (*model.Execution, error) {
	ret := _m.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetExecution")
	}

	var r0 *model.Execution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Execution, error)); ok {
		return rf(ctx, executionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Execution); ok {
		r0 = rf(ctx, executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Execution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecution'
type MockOps_GetExecution_Call struct {
	*mock.Call
}

// GetExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - executionID string
func (_e *MockOps_Expecter) GetExecution(ctx interface{}, executionID interface{}) *MockOps_GetExecution_Call {
	return &MockOps_GetExecution_Call{Call: _e.mock.On("GetExecution", ctx, executionID)}
}

func (_c *MockOps_GetExecution_Call) Run(run func(ctx context.Context, executionID string)) *MockOps_GetExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetExecution_Call) Return(_a0 *model.Execution, _a1 error) *MockOps_GetExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetExecution_Call) RunAndReturn(run func(context.Context, string) (*model.Execution, error)) *MockOps_GetExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetFatalErrors provides a mock function with given fields: ctx, keyPrefix, fatalErrs, errs
func (_m *MockOps) GetFatalErrors(ctx context.Context, keyPrefix string, fatalErrs chan<- *model.FatalError, errs chan<- error) {
	_m.Called(ctx, keyPrefix, fatalErrs, errs)
}

// MockOps_GetFatalErrors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFatalErrors'
type MockOps_GetFatalErrors_Call struct {
	*mock.Call
}

// GetFatalErrors is a helper method to define mock.On call
//   - ctx context.Context
//   - keyPrefix string
//   - fatalErrs chan<- *model.FatalError
//   - errs chan<- error
func (_e *MockOps_Expecter) GetFatalErrors(ctx interface{}, keyPrefix interface{}, fatalErrs interface{}, errs interface{}) *MockOps_GetFatalErrors_Call {
	return &MockOps_GetFatalErrors_Call{Call: _e.mock.On("GetFatalErrors", ctx, keyPrefix, fatalErrs, errs)}
}

func (_c *MockOps_GetFatalErrors_Call) Run(run func(ctx context.Context, keyPrefix string, fatalErrs chan<- *model.FatalError, errs chan<- error)) *MockOps_GetFatalErrors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(chan<- *model.FatalError), args[3].(chan<- error))
	})
	return _c
}

func (_c *MockOps_GetFatalErrors_Call) Return() *MockOps_GetFatalErrors_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_GetFatalErrors_Call) RunAndReturn(run func(context.Context, string, chan<- *model.FatalError, chan<- error)) *MockOps_GetFatalErrors_Call {
	_c.Call.Return(run)
	return _c
}

// GetJob provides a mock function with given fields: ctx, trackingID
func (_m *MockOps) GetJob(ctx context.Context, trackingID string) (*model.WorkflowState, error) {
	ret := _m.Called(ctx, trackingID)

	if len(ret) == 0 {
		panic("no return value specified for GetJob")
	}

	var r0 *model.WorkflowState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.WorkflowState, error)); ok {
		return rf(ctx, trackingID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.WorkflowState); ok {
		r0 = rf(ctx, trackingID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.WorkflowState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, trackingID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJob'
type MockOps_GetJob_Call struct {
	*mock.Call
}

// GetJob is a helper method to define mock.On call
//   - ctx context.Context
//   - trackingID string
func (_e *MockOps_Expecter) GetJob(ctx interface{}, trackingID interface{}) *MockOps_GetJob_Call {
	return &MockOps_GetJob_Call{Call: _e.mock.On("GetJob", ctx, trackingID)}
}

func (_c *MockOps_GetJob_Call) Run(run func(ctx context.Context, trackingID string)) *MockOps_GetJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetJob_Call) Return(_a0 *model.WorkflowState, _a1 error) *MockOps_GetJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetJob_Call) RunAndReturn(run func(context.Context, string) (*model.WorkflowState, error)) *MockOps_GetJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestWorkflowVersion provides a mock function with given fields: ctx, workflowName
func (_m *MockOps) GetLatestWorkflowVersion(ctx context.Context, workflowName string) (string, error) {
	ret := _m.Called(ctx, workflowName)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestWorkflowVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, workflowName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, workflowName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, workflowName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetLatestWorkflowVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestWorkflowVersion'
type MockOps_GetLatestWorkflowVersion_Call struct {
	*mock.Call
}

// GetLatestWorkflowVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowName string
func (_e *MockOps_Expecter) GetLatestWorkflowVersion(ctx interface{}, workflowName interface{}) *MockOps_GetLatestWorkflowVersion_Call {
	return &MockOps_GetLatestWorkflowVersion_Call{Call: _e.mock.On("GetLatestWorkflowVersion", ctx, workflowName)}
}

func (_c *MockOps_GetLatestWorkflowVersion_Call) Run(run func(ctx context.Context, workflowName string)) *MockOps_GetLatestWorkflowVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetLatestWorkflowVersion_Call) Return(_a0 string, _a1 error) *MockOps_GetLatestWorkflowVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetLatestWorkflowVersion_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_GetLatestWorkflowVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessHistory provides a mock function with given fields: ctx, processInstanceId, wch, errs
func (_m *MockOps) GetProcessHistory(ctx context.Context, processInstanceId string, wch chan<- *model.ProcessHistoryEntry, errs chan<- error) {
	_m.Called(ctx, processInstanceId, wch, errs)
}

// MockOps_GetProcessHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessHistory'
type MockOps_GetProcessHistory_Call struct {
	*mock.Call
}

// GetProcessHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceId string
//   - wch chan<- *model.ProcessHistoryEntry
//   - errs chan<- error
func (_e *MockOps_Expecter) GetProcessHistory(ctx interface{}, processInstanceId interface{}, wch interface{}, errs interface{}) *MockOps_GetProcessHistory_Call {
	return &MockOps_GetProcessHistory_Call{Call: _e.mock.On("GetProcessHistory", ctx, processInstanceId, wch, errs)}
}

func (_c *MockOps_GetProcessHistory_Call) Run(run func(ctx context.Context, processInstanceId string, wch chan<- *model.ProcessHistoryEntry, errs chan<- error)) *MockOps_GetProcessHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(chan<- *model.ProcessHistoryEntry), args[3].(chan<- error))
	})
	return _c
}

func (_c *MockOps_GetProcessHistory_Call) Return() *MockOps_GetProcessHistory_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_GetProcessHistory_Call) RunAndReturn(run func(context.Context, string, chan<- *model.ProcessHistoryEntry, chan<- error)) *MockOps_GetProcessHistory_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessHistoryItem provides a mock function with given fields: ctx, processInstanceID, trackingID, historyType
func (_m *MockOps) GetProcessHistoryItem(ctx context.Context, processInstanceID string, trackingID string, historyType model.ProcessHistoryType) (*model.ProcessHistoryEntry, error) {
	ret := _m.Called(ctx, processInstanceID, trackingID, historyType)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessHistoryItem")
	}

	var r0 *model.ProcessHistoryEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, model.ProcessHistoryType) (*model.ProcessHistoryEntry, error)); ok {
		return rf(ctx, processInstanceID, trackingID, historyType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, model.ProcessHistoryType) *model.ProcessHistoryEntry); ok {
		r0 = rf(ctx, processInstanceID, trackingID, historyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessHistoryEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, model.ProcessHistoryType) error); ok {
		r1 = rf(ctx, processInstanceID, trackingID, historyType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetProcessHistoryItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessHistoryItem'
type MockOps_GetProcessHistoryItem_Call struct {
	*mock.Call
}

// GetProcessHistoryItem is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceID string
//   - trackingID string
//   - historyType model.ProcessHistoryType
func (_e *MockOps_Expecter) GetProcessHistoryItem(ctx interface{}, processInstanceID interface{}, trackingID interface{}, historyType interface{}) *MockOps_GetProcessHistoryItem_Call {
	return &MockOps_GetProcessHistoryItem_Call{Call: _e.mock.On("GetProcessHistoryItem", ctx, processInstanceID, trackingID, historyType)}
}

func (_c *MockOps_GetProcessHistoryItem_Call) Run(run func(ctx context.Context, processInstanceID string, trackingID string, historyType model.ProcessHistoryType)) *MockOps_GetProcessHistoryItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(model.ProcessHistoryType))
	})
	return _c
}

func (_c *MockOps_GetProcessHistoryItem_Call) Return(_a0 *model.ProcessHistoryEntry, _a1 error) *MockOps_GetProcessHistoryItem_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetProcessHistoryItem_Call) RunAndReturn(run func(context.Context, string, string, model.ProcessHistoryType) (*model.ProcessHistoryEntry, error)) *MockOps_GetProcessHistoryItem_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessIdFor provides a mock function with given fields: ctx, startEventMessageName
func (_m *MockOps) GetProcessIdFor(ctx context.Context, startEventMessageName string) (string, error) {
	ret := _m.Called(ctx, startEventMessageName)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessIdFor")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, startEventMessageName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, startEventMessageName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, startEventMessageName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetProcessIdFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessIdFor'
type MockOps_GetProcessIdFor_Call struct {
	*mock.Call
}

// GetProcessIdFor is a helper method to define mock.On call
//   - ctx context.Context
//   - startEventMessageName string
func (_e *MockOps_Expecter) GetProcessIdFor(ctx interface{}, startEventMessageName interface{}) *MockOps_GetProcessIdFor_Call {
	return &MockOps_GetProcessIdFor_Call{Call: _e.mock.On("GetProcessIdFor", ctx, startEventMessageName)}
}

func (_c *MockOps_GetProcessIdFor_Call) Run(run func(ctx context.Context, startEventMessageName string)) *MockOps_GetProcessIdFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetProcessIdFor_Call) Return(_a0 string, _a1 error) *MockOps_GetProcessIdFor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetProcessIdFor_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_GetProcessIdFor_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessInstance provides a mock function with given fields: ctx, processInstanceID
func (_m *MockOps) GetProcessInstance(ctx context.Context, processInstanceID string) (*model.ProcessInstance, error) {
	ret := _m.Called(ctx, processInstanceID)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessInstance")
	}

	var r0 *model.ProcessInstance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.ProcessInstance, error)); ok {
		return rf(ctx, processInstanceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.ProcessInstance); ok {
		r0 = rf(ctx, processInstanceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, processInstanceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetProcessInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessInstance'
type MockOps_GetProcessInstance_Call struct {
	*mock.Call
}

// GetProcessInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceID string
func (_e *MockOps_Expecter) GetProcessInstance(ctx interface{}, processInstanceID interface{}) *MockOps_GetProcessInstance_Call {
	return &MockOps_GetProcessInstance_Call{Call: _e.mock.On("GetProcessInstance", ctx, processInstanceID)}
}

func (_c *MockOps_GetProcessInstance_Call) Run(run func(ctx context.Context, processInstanceID string)) *MockOps_GetProcessInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetProcessInstance_Call) Return(_a0 *model.ProcessInstance, _a1 error) *MockOps_GetProcessInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetProcessInstance_Call) RunAndReturn(run func(context.Context, string) (*model.ProcessInstance, error)) *MockOps_GetProcessInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskSpecByUID provides a mock function with given fields: ctx, uid
func (_m *MockOps) GetTaskSpecByUID(ctx context.Context, uid string) (*model.TaskSpec, error) {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskSpecByUID")
	}

	var r0 *model.TaskSpec
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.TaskSpec, error)); ok {
		return rf(ctx, uid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.TaskSpec); ok {
		r0 = rf(ctx, uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TaskSpec)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, uid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetTaskSpecByUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskSpecByUID'
type MockOps_GetTaskSpecByUID_Call struct {
	*mock.Call
}

// GetTaskSpecByUID is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
func (_e *MockOps_Expecter) GetTaskSpecByUID(ctx interface{}, uid interface{}) *MockOps_GetTaskSpecByUID_Call {
	return &MockOps_GetTaskSpecByUID_Call{Call: _e.mock.On("GetTaskSpecByUID", ctx, uid)}
}

func (_c *MockOps_GetTaskSpecByUID_Call) Run(run func(ctx context.Context, uid string)) *MockOps_GetTaskSpecByUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetTaskSpecByUID_Call) Return(_a0 *model.TaskSpec, _a1 error) *MockOps_GetTaskSpecByUID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetTaskSpecByUID_Call) RunAndReturn(run func(context.Context, string) (*model.TaskSpec, error)) *MockOps_GetTaskSpecByUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskSpecUID provides a mock function with given fields: ctx, name
func (_m *MockOps) GetTaskSpecUID(ctx context.Context, name string) (string, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskSpecUID")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetTaskSpecUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskSpecUID'
type MockOps_GetTaskSpecUID_Call struct {
	*mock.Call
}

// GetTaskSpecUID is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockOps_Expecter) GetTaskSpecUID(ctx interface{}, name interface{}) *MockOps_GetTaskSpecUID_Call {
	return &MockOps_GetTaskSpecUID_Call{Call: _e.mock.On("GetTaskSpecUID", ctx, name)}
}

func (_c *MockOps_GetTaskSpecUID_Call) Run(run func(ctx context.Context, name string)) *MockOps_GetTaskSpecUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetTaskSpecUID_Call) Return(_a0 string, _a1 error) *MockOps_GetTaskSpecUID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetTaskSpecUID_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_GetTaskSpecUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskSpecUsage provides a mock function with given fields: ctx, uid
func (_m *MockOps) GetTaskSpecUsage(ctx context.Context, uid []string) (*model.TaskSpecUsageReport, error) {
	ret := _m.Called(ctx, uid)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskSpecUsage")
	}

	var r0 *model.TaskSpecUsageReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (*model.TaskSpecUsageReport, error)); ok {
		return rf(ctx, uid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) *model.TaskSpecUsageReport); ok {
		r0 = rf(ctx, uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TaskSpecUsageReport)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, uid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetTaskSpecUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskSpecUsage'
type MockOps_GetTaskSpecUsage_Call struct {
	*mock.Call
}

// GetTaskSpecUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - uid []string
func (_e *MockOps_Expecter) GetTaskSpecUsage(ctx interface{}, uid interface{}) *MockOps_GetTaskSpecUsage_Call {
	return &MockOps_GetTaskSpecUsage_Call{Call: _e.mock.On("GetTaskSpecUsage", ctx, uid)}
}

func (_c *MockOps_GetTaskSpecUsage_Call) Run(run func(ctx context.Context, uid []string)) *MockOps_GetTaskSpecUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockOps_GetTaskSpecUsage_Call) Return(_a0 *model.TaskSpecUsageReport, _a1 error) *MockOps_GetTaskSpecUsage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetTaskSpecUsage_Call) RunAndReturn(run func(context.Context, []string) (*model.TaskSpecUsageReport, error)) *MockOps_GetTaskSpecUsage_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskSpecUsageByName provides a mock function with given fields: ctx, name
func (_m *MockOps) GetTaskSpecUsageByName(ctx context.Context, name string) (*model.TaskSpecUsageReport, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskSpecUsageByName")
	}

	var r0 *model.TaskSpecUsageReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.TaskSpecUsageReport, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.TaskSpecUsageReport); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TaskSpecUsageReport)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetTaskSpecUsageByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskSpecUsageByName'
type MockOps_GetTaskSpecUsageByName_Call struct {
	*mock.Call
}

// GetTaskSpecUsageByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockOps_Expecter) GetTaskSpecUsageByName(ctx interface{}, name interface{}) *MockOps_GetTaskSpecUsageByName_Call {
	return &MockOps_GetTaskSpecUsageByName_Call{Call: _e.mock.On("GetTaskSpecUsageByName", ctx, name)}
}

func (_c *MockOps_GetTaskSpecUsageByName_Call) Run(run func(ctx context.Context, name string)) *MockOps_GetTaskSpecUsageByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetTaskSpecUsageByName_Call) Return(_a0 *model.TaskSpecUsageReport, _a1 error) *MockOps_GetTaskSpecUsageByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetTaskSpecUsageByName_Call) RunAndReturn(run func(context.Context, string) (*model.TaskSpecUsageReport, error)) *MockOps_GetTaskSpecUsageByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskSpecVersions provides a mock function with given fields: ctx, name
func (_m *MockOps) GetTaskSpecVersions(ctx context.Context, name string) (*model.TaskSpecVersions, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskSpecVersions")
	}

	var r0 *model.TaskSpecVersions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.TaskSpecVersions, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.TaskSpecVersions); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.TaskSpecVersions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetTaskSpecVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskSpecVersions'
type MockOps_GetTaskSpecVersions_Call struct {
	*mock.Call
}

// GetTaskSpecVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockOps_Expecter) GetTaskSpecVersions(ctx interface{}, name interface{}) *MockOps_GetTaskSpecVersions_Call {
	return &MockOps_GetTaskSpecVersions_Call{Call: _e.mock.On("GetTaskSpecVersions", ctx, name)}
}

func (_c *MockOps_GetTaskSpecVersions_Call) Run(run func(ctx context.Context, name string)) *MockOps_GetTaskSpecVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetTaskSpecVersions_Call) Return(_a0 *model.TaskSpecVersions, _a1 error) *MockOps_GetTaskSpecVersions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetTaskSpecVersions_Call) RunAndReturn(run func(context.Context, string) (*model.TaskSpecVersions, error)) *MockOps_GetTaskSpecVersions_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserTaskIDs provides a mock function with given fields: ctx, owner
func (_m *MockOps) GetUserTaskIDs(ctx context.Context, owner string) (*model.UserTasks, error) {
	ret := _m.Called(ctx, owner)

	if len(ret) == 0 {
		panic("no return value specified for GetUserTaskIDs")
	}

	var r0 *model.UserTasks
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.UserTasks, error)); ok {
		return rf(ctx, owner)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.UserTasks); ok {
		r0 = rf(ctx, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.UserTasks)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetUserTaskIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserTaskIDs'
type MockOps_GetUserTaskIDs_Call struct {
	*mock.Call
}

// GetUserTaskIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
func (_e *MockOps_Expecter) GetUserTaskIDs(ctx interface{}, owner interface{}) *MockOps_GetUserTaskIDs_Call {
	return &MockOps_GetUserTaskIDs_Call{Call: _e.mock.On("GetUserTaskIDs", ctx, owner)}
}

func (_c *MockOps_GetUserTaskIDs_Call) Run(run func(ctx context.Context, owner string)) *MockOps_GetUserTaskIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetUserTaskIDs_Call) Return(_a0 *model.UserTasks, _a1 error) *MockOps_GetUserTaskIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetUserTaskIDs_Call) RunAndReturn(run func(context.Context, string) (*model.UserTasks, error)) *MockOps_GetUserTaskIDs_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflow provides a mock function with given fields: ctx, workflowID
func (_m *MockOps) GetWorkflow(ctx context.Context, workflowID string) (*model.Workflow, error) {
	ret := _m.Called(ctx, workflowID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflow")
	}

	var r0 *model.Workflow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Workflow, error)); ok {
		return rf(ctx, workflowID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Workflow); ok {
		r0 = rf(ctx, workflowID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Workflow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, workflowID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflow'
type MockOps_GetWorkflow_Call struct {
	*mock.Call
}

// GetWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowID string
func (_e *MockOps_Expecter) GetWorkflow(ctx interface{}, workflowID interface{}) *MockOps_GetWorkflow_Call {
	return &MockOps_GetWorkflow_Call{Call: _e.mock.On("GetWorkflow", ctx, workflowID)}
}

func (_c *MockOps_GetWorkflow_Call) Run(run func(ctx context.Context, workflowID string)) *MockOps_GetWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetWorkflow_Call) Return(_a0 *model.Workflow, _a1 error) *MockOps_GetWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetWorkflow_Call) RunAndReturn(run func(context.Context, string) (*model.Workflow, error)) *MockOps_GetWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowNameFor provides a mock function with given fields: ctx, processId
func (_m *MockOps) GetWorkflowNameFor(ctx context.Context, processId string) (string, error) {
	ret := _m.Called(ctx, processId)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowNameFor")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, processId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, processId)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, processId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_GetWorkflowNameFor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowNameFor'
type MockOps_GetWorkflowNameFor_Call struct {
	*mock.Call
}

// GetWorkflowNameFor is a helper method to define mock.On call
//   - ctx context.Context
//   - processId string
func (_e *MockOps_Expecter) GetWorkflowNameFor(ctx interface{}, processId interface{}) *MockOps_GetWorkflowNameFor_Call {
	return &MockOps_GetWorkflowNameFor_Call{Call: _e.mock.On("GetWorkflowNameFor", ctx, processId)}
}

func (_c *MockOps_GetWorkflowNameFor_Call) Run(run func(ctx context.Context, processId string)) *MockOps_GetWorkflowNameFor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_GetWorkflowNameFor_Call) Return(_a0 string, _a1 error) *MockOps_GetWorkflowNameFor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_GetWorkflowNameFor_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_GetWorkflowNameFor_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowVersions provides a mock function with given fields: ctx, workflowName, wch, errs
func (_m *MockOps) GetWorkflowVersions(ctx context.Context, workflowName string, wch chan<- *model.WorkflowVersion, errs chan<- error) {
	_m.Called(ctx, workflowName, wch, errs)
}

// MockOps_GetWorkflowVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowVersions'
type MockOps_GetWorkflowVersions_Call struct {
	*mock.Call
}

// GetWorkflowVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowName string
//   - wch chan<- *model.WorkflowVersion
//   - errs chan<- error
func (_e *MockOps_Expecter) GetWorkflowVersions(ctx interface{}, workflowName interface{}, wch interface{}, errs interface{}) *MockOps_GetWorkflowVersions_Call {
	return &MockOps_GetWorkflowVersions_Call{Call: _e.mock.On("GetWorkflowVersions", ctx, workflowName, wch, errs)}
}

func (_c *MockOps_GetWorkflowVersions_Call) Run(run func(ctx context.Context, workflowName string, wch chan<- *model.WorkflowVersion, errs chan<- error)) *MockOps_GetWorkflowVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(chan<- *model.WorkflowVersion), args[3].(chan<- error))
	})
	return _c
}

func (_c *MockOps_GetWorkflowVersions_Call) Return() *MockOps_GetWorkflowVersions_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_GetWorkflowVersions_Call) RunAndReturn(run func(context.Context, string, chan<- *model.WorkflowVersion, chan<- error)) *MockOps_GetWorkflowVersions_Call {
	_c.Call.Return(run)
	return _c
}

// HandleWorkflowError provides a mock function with given fields: ctx, errorCode, inVars, state
func (_m *MockOps) HandleWorkflowError(ctx context.Context, errorCode string, inVars []byte, state *model.WorkflowState) error {
	ret := _m.Called(ctx, errorCode, inVars, state)

	if len(ret) == 0 {
		panic("no return value specified for HandleWorkflowError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, *model.WorkflowState) error); ok {
		r0 = rf(ctx, errorCode, inVars, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_HandleWorkflowError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleWorkflowError'
type MockOps_HandleWorkflowError_Call struct {
	*mock.Call
}

// HandleWorkflowError is a helper method to define mock.On call
//   - ctx context.Context
//   - errorCode string
//   - inVars []byte
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) HandleWorkflowError(ctx interface{}, errorCode interface{}, inVars interface{}, state interface{}) *MockOps_HandleWorkflowError_Call {
	return &MockOps_HandleWorkflowError_Call{Call: _e.mock.On("HandleWorkflowError", ctx, errorCode, inVars, state)}
}

func (_c *MockOps_HandleWorkflowError_Call) Run(run func(ctx context.Context, errorCode string, inVars []byte, state *model.WorkflowState)) *MockOps_HandleWorkflowError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), args[3].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_HandleWorkflowError_Call) Return(_a0 error) *MockOps_HandleWorkflowError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_HandleWorkflowError_Call) RunAndReturn(run func(context.Context, string, []byte, *model.WorkflowState) error) *MockOps_HandleWorkflowError_Call {
	_c.Call.Return(run)
	return _c
}

// HasValidExecution provides a mock function with given fields: ctx, executionId
func (_m *MockOps) HasValidExecution(ctx context.Context, executionId string) (*model.Execution, error) {
	ret := _m.Called(ctx, executionId)

	if len(ret) == 0 {
		panic("no return value specified for HasValidExecution")
	}

	var r0 *model.Execution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*model.Execution, error)); ok {
		return rf(ctx, executionId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *model.Execution); ok {
		r0 = rf(ctx, executionId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Execution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, executionId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_HasValidExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasValidExecution'
type MockOps_HasValidExecution_Call struct {
	*mock.Call
}

// HasValidExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - executionId string
func (_e *MockOps_Expecter) HasValidExecution(ctx interface{}, executionId interface{}) *MockOps_HasValidExecution_Call {
	return &MockOps_HasValidExecution_Call{Call: _e.mock.On("HasValidExecution", ctx, executionId)}
}

func (_c *MockOps_HasValidExecution_Call) Run(run func(ctx context.Context, executionId string)) *MockOps_HasValidExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_HasValidExecution_Call) Return(_a0 *model.Execution, _a1 error) *MockOps_HasValidExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_HasValidExecution_Call) RunAndReturn(run func(context.Context, string) (*model.Execution, error)) *MockOps_HasValidExecution_Call {
	_c.Call.Return(run)
	return _c
}

// HasValidProcess provides a mock function with given fields: ctx, processInstanceId, executionId
func (_m *MockOps) HasValidProcess(ctx context.Context, processInstanceId string, executionId string) (*model.ProcessInstance, *model.Execution, error) {
	ret := _m.Called(ctx, processInstanceId, executionId)

	if len(ret) == 0 {
		panic("no return value specified for HasValidProcess")
	}

	var r0 *model.ProcessInstance
	var r1 *model.Execution
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*model.ProcessInstance, *model.Execution, error)); ok {
		return rf(ctx, processInstanceId, executionId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *model.ProcessInstance); ok {
		r0 = rf(ctx, processInstanceId, executionId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ProcessInstance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) *model.Execution); ok {
		r1 = rf(ctx, processInstanceId, executionId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*model.Execution)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, processInstanceId, executionId)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockOps_HasValidProcess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasValidProcess'
type MockOps_HasValidProcess_Call struct {
	*mock.Call
}

// HasValidProcess is a helper method to define mock.On call
//   - ctx context.Context
//   - processInstanceId string
//   - executionId string
func (_e *MockOps_Expecter) HasValidProcess(ctx interface{}, processInstanceId interface{}, executionId interface{}) *MockOps_HasValidProcess_Call {
	return &MockOps_HasValidProcess_Call{Call: _e.mock.On("HasValidProcess", ctx, processInstanceId, executionId)}
}

func (_c *MockOps_HasValidProcess_Call) Run(run func(ctx context.Context, processInstanceId string, executionId string)) *MockOps_HasValidProcess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockOps_HasValidProcess_Call) Return(_a0 *model.ProcessInstance, _a1 *model.Execution, _a2 error) *MockOps_HasValidProcess_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockOps_HasValidProcess_Call) RunAndReturn(run func(context.Context, string, string) (*model.ProcessInstance, *model.Execution, error)) *MockOps_HasValidProcess_Call {
	_c.Call.Return(run)
	return _c
}

// Heartbeat provides a mock function with given fields: ctx, req
func (_m *MockOps) Heartbeat(ctx context.Context, req *model.HeartbeatRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Heartbeat")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.HeartbeatRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_Heartbeat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Heartbeat'
type MockOps_Heartbeat_Call struct {
	*mock.Call
}

// Heartbeat is a helper method to define mock.On call
//   - ctx context.Context
//   - req *model.HeartbeatRequest
func (_e *MockOps_Expecter) Heartbeat(ctx interface{}, req interface{}) *MockOps_Heartbeat_Call {
	return &MockOps_Heartbeat_Call{Call: _e.mock.On("Heartbeat", ctx, req)}
}

func (_c *MockOps_Heartbeat_Call) Run(run func(ctx context.Context, req *model.HeartbeatRequest)) *MockOps_Heartbeat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.HeartbeatRequest))
	})
	return _c
}

func (_c *MockOps_Heartbeat_Call) Return(_a0 error) *MockOps_Heartbeat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_Heartbeat_Call) RunAndReturn(run func(context.Context, *model.HeartbeatRequest) error) *MockOps_Heartbeat_Call {
	_c.Call.Return(run)
	return _c
}

// Launch provides a mock function with given fields: ctx, processId, vars, headers
func (_m *MockOps) Launch(ctx context.Context, processId string, vars []byte, headers []byte) (string, string, error) {
	ret := _m.Called(ctx, processId, vars, headers)

	if len(ret) == 0 {
		panic("no return value specified for Launch")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, []byte) (string, string, error)); ok {
		return rf(ctx, processId, vars, headers)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, []byte) string); ok {
		r0 = rf(ctx, processId, vars, headers)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []byte, []byte) string); ok {
		r1 = rf(ctx, processId, vars, headers)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, []byte, []byte) error); ok {
		r2 = rf(ctx, processId, vars, headers)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockOps_Launch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Launch'
type MockOps_Launch_Call struct {
	*mock.Call
}

// Launch is a helper method to define mock.On call
//   - ctx context.Context
//   - processId string
//   - vars []byte
//   - headers []byte
func (_e *MockOps_Expecter) Launch(ctx interface{}, processId interface{}, vars interface{}, headers interface{}) *MockOps_Launch_Call {
	return &MockOps_Launch_Call{Call: _e.mock.On("Launch", ctx, processId, vars, headers)}
}

func (_c *MockOps_Launch_Call) Run(run func(ctx context.Context, processId string, vars []byte, headers []byte)) *MockOps_Launch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), args[3].([]byte))
	})
	return _c
}

func (_c *MockOps_Launch_Call) Return(_a0 string, _a1 string, _a2 error) *MockOps_Launch_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockOps_Launch_Call) RunAndReturn(run func(context.Context, string, []byte, []byte) (string, string, error)) *MockOps_Launch_Call {
	_c.Call.Return(run)
	return _c
}

// LaunchWithParent provides a mock function with given fields: ctx, processId, ID, vrs, headers, parentpiID, parentElID
func (_m *MockOps) LaunchWithParent(ctx context.Context, processId string, ID common.TrackingID, vrs []byte, headers []byte, parentpiID string, parentElID string) (string, string, error) {
	ret := _m.Called(ctx, processId, ID, vrs, headers, parentpiID, parentElID)

	if len(ret) == 0 {
		panic("no return value specified for LaunchWithParent")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, common.TrackingID, []byte, []byte, string, string) (string, string, error)); ok {
		return rf(ctx, processId, ID, vrs, headers, parentpiID, parentElID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, common.TrackingID, []byte, []byte, string, string) string); ok {
		r0 = rf(ctx, processId, ID, vrs, headers, parentpiID, parentElID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, common.TrackingID, []byte, []byte, string, string) string); ok {
		r1 = rf(ctx, processId, ID, vrs, headers, parentpiID, parentElID)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, common.TrackingID, []byte, []byte, string, string) error); ok {
		r2 = rf(ctx, processId, ID, vrs, headers, parentpiID, parentElID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockOps_LaunchWithParent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LaunchWithParent'
type MockOps_LaunchWithParent_Call struct {
	*mock.Call
}

// LaunchWithParent is a helper method to define mock.On call
//   - ctx context.Context
//   - processId string
//   - ID common.TrackingID
//   - vrs []byte
//   - headers []byte
//   - parentpiID string
//   - parentElID string
func (_e *MockOps_Expecter) LaunchWithParent(ctx interface{}, processId interface{}, ID interface{}, vrs interface{}, headers interface{}, parentpiID interface{}, parentElID interface{}) *MockOps_LaunchWithParent_Call {
	return &MockOps_LaunchWithParent_Call{Call: _e.mock.On("LaunchWithParent", ctx, processId, ID, vrs, headers, parentpiID, parentElID)}
}

func (_c *MockOps_LaunchWithParent_Call) Run(run func(ctx context.Context, processId string, ID common.TrackingID, vrs []byte, headers []byte, parentpiID string, parentElID string)) *MockOps_LaunchWithParent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(common.TrackingID), args[3].([]byte), args[4].([]byte), args[5].(string), args[6].(string))
	})
	return _c
}

func (_c *MockOps_LaunchWithParent_Call) Return(_a0 string, _a1 string, _a2 error) *MockOps_LaunchWithParent_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockOps_LaunchWithParent_Call) RunAndReturn(run func(context.Context, string, common.TrackingID, []byte, []byte, string, string) (string, string, error)) *MockOps_LaunchWithParent_Call {
	_c.Call.Return(run)
	return _c
}

// ListExecutableProcesses provides a mock function with given fields: ctx, wch, errs
func (_m *MockOps) ListExecutableProcesses(ctx context.Context, wch chan<- *model.ListExecutableProcessesItem, errs chan<- error) {
	_m.Called(ctx, wch, errs)
}

// MockOps_ListExecutableProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExecutableProcesses'
type MockOps_ListExecutableProcesses_Call struct {
	*mock.Call
}

// ListExecutableProcesses is a helper method to define mock.On call
//   - ctx context.Context
//   - wch chan<- *model.ListExecutableProcessesItem
//   - errs chan<- error
func (_e *MockOps_Expecter) ListExecutableProcesses(ctx interface{}, wch interface{}, errs interface{}) *MockOps_ListExecutableProcesses_Call {
	return &MockOps_ListExecutableProcesses_Call{Call: _e.mock.On("ListExecutableProcesses", ctx, wch, errs)}
}

func (_c *MockOps_ListExecutableProcesses_Call) Run(run func(ctx context.Context, wch chan<- *model.ListExecutableProcessesItem, errs chan<- error)) *MockOps_ListExecutableProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(chan<- *model.ListExecutableProcessesItem), args[2].(chan<- error))
	})
	return _c
}

func (_c *MockOps_ListExecutableProcesses_Call) Return() *MockOps_ListExecutableProcesses_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_ListExecutableProcesses_Call) RunAndReturn(run func(context.Context, chan<- *model.ListExecutableProcessesItem, chan<- error)) *MockOps_ListExecutableProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// ListExecutionProcesses provides a mock function with given fields: ctx, id
func (_m *MockOps) ListExecutionProcesses(ctx context.Context, id string) ([]string, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ListExecutionProcesses")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_ListExecutionProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExecutionProcesses'
type MockOps_ListExecutionProcesses_Call struct {
	*mock.Call
}

// ListExecutionProcesses is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockOps_Expecter) ListExecutionProcesses(ctx interface{}, id interface{}) *MockOps_ListExecutionProcesses_Call {
	return &MockOps_ListExecutionProcesses_Call{Call: _e.mock.On("ListExecutionProcesses", ctx, id)}
}

func (_c *MockOps_ListExecutionProcesses_Call) Run(run func(ctx context.Context, id string)) *MockOps_ListExecutionProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_ListExecutionProcesses_Call) Return(_a0 []string, _a1 error) *MockOps_ListExecutionProcesses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_ListExecutionProcesses_Call) RunAndReturn(run func(context.Context, string) ([]string, error)) *MockOps_ListExecutionProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// ListExecutions provides a mock function with given fields: ctx, workflowName, wch, errs
func (_m *MockOps) ListExecutions(ctx context.Context, workflowName string, wch chan<- *model.ListExecutionItem, errs chan<- error) {
	_m.Called(ctx, workflowName, wch, errs)
}

// MockOps_ListExecutions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExecutions'
type MockOps_ListExecutions_Call struct {
	*mock.Call
}

// ListExecutions is a helper method to define mock.On call
//   - ctx context.Context
//   - workflowName string
//   - wch chan<- *model.ListExecutionItem
//   - errs chan<- error
func (_e *MockOps_Expecter) ListExecutions(ctx interface{}, workflowName interface{}, wch interface{}, errs interface{}) *MockOps_ListExecutions_Call {
	return &MockOps_ListExecutions_Call{Call: _e.mock.On("ListExecutions", ctx, workflowName, wch, errs)}
}

func (_c *MockOps_ListExecutions_Call) Run(run func(ctx context.Context, workflowName string, wch chan<- *model.ListExecutionItem, errs chan<- error)) *MockOps_ListExecutions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(chan<- *model.ListExecutionItem), args[3].(chan<- error))
	})
	return _c
}

func (_c *MockOps_ListExecutions_Call) Return() *MockOps_ListExecutions_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_ListExecutions_Call) RunAndReturn(run func(context.Context, string, chan<- *model.ListExecutionItem, chan<- error)) *MockOps_ListExecutions_Call {
	_c.Call.Return(run)
	return _c
}

// ListTaskSpecUIDs provides a mock function with given fields: ctx, deprecated
func (_m *MockOps) ListTaskSpecUIDs(ctx context.Context, deprecated bool) ([]string, error) {
	ret := _m.Called(ctx, deprecated)

	if len(ret) == 0 {
		panic("no return value specified for ListTaskSpecUIDs")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) ([]string, error)); ok {
		return rf(ctx, deprecated)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) []string); ok {
		r0 = rf(ctx, deprecated)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, deprecated)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_ListTaskSpecUIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTaskSpecUIDs'
type MockOps_ListTaskSpecUIDs_Call struct {
	*mock.Call
}

// ListTaskSpecUIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - deprecated bool
func (_e *MockOps_Expecter) ListTaskSpecUIDs(ctx interface{}, deprecated interface{}) *MockOps_ListTaskSpecUIDs_Call {
	return &MockOps_ListTaskSpecUIDs_Call{Call: _e.mock.On("ListTaskSpecUIDs", ctx, deprecated)}
}

func (_c *MockOps_ListTaskSpecUIDs_Call) Run(run func(ctx context.Context, deprecated bool)) *MockOps_ListTaskSpecUIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *MockOps_ListTaskSpecUIDs_Call) Return(_a0 []string, _a1 error) *MockOps_ListTaskSpecUIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_ListTaskSpecUIDs_Call) RunAndReturn(run func(context.Context, bool) ([]string, error)) *MockOps_ListTaskSpecUIDs_Call {
	_c.Call.Return(run)
	return _c
}

// ListWorkflows provides a mock function with given fields: ctx, res, errs
func (_m *MockOps) ListWorkflows(ctx context.Context, res chan<- *model.ListWorkflowResponse, errs chan<- error) {
	_m.Called(ctx, res, errs)
}

// MockOps_ListWorkflows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWorkflows'
type MockOps_ListWorkflows_Call struct {
	*mock.Call
}

// ListWorkflows is a helper method to define mock.On call
//   - ctx context.Context
//   - res chan<- *model.ListWorkflowResponse
//   - errs chan<- error
func (_e *MockOps_Expecter) ListWorkflows(ctx interface{}, res interface{}, errs interface{}) *MockOps_ListWorkflows_Call {
	return &MockOps_ListWorkflows_Call{Call: _e.mock.On("ListWorkflows", ctx, res, errs)}
}

func (_c *MockOps_ListWorkflows_Call) Run(run func(ctx context.Context, res chan<- *model.ListWorkflowResponse, errs chan<- error)) *MockOps_ListWorkflows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(chan<- *model.ListWorkflowResponse), args[2].(chan<- error))
	})
	return _c
}

func (_c *MockOps_ListWorkflows_Call) Return() *MockOps_ListWorkflows_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_ListWorkflows_Call) RunAndReturn(run func(context.Context, chan<- *model.ListWorkflowResponse, chan<- error)) *MockOps_ListWorkflows_Call {
	_c.Call.Return(run)
	return _c
}

// LoadWorkflow provides a mock function with given fields: ctx, _a1
func (_m *MockOps) LoadWorkflow(ctx context.Context, _a1 *model.Workflow) (string, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LoadWorkflow")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow) (string, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow) string); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.Workflow) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_LoadWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadWorkflow'
type MockOps_LoadWorkflow_Call struct {
	*mock.Call
}

// LoadWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *model.Workflow
func (_e *MockOps_Expecter) LoadWorkflow(ctx interface{}, _a1 interface{}) *MockOps_LoadWorkflow_Call {
	return &MockOps_LoadWorkflow_Call{Call: _e.mock.On("LoadWorkflow", ctx, _a1)}
}

func (_c *MockOps_LoadWorkflow_Call) Run(run func(ctx context.Context, _a1 *model.Workflow)) *MockOps_LoadWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Workflow))
	})
	return _c
}

func (_c *MockOps_LoadWorkflow_Call) Return(_a0 string, _a1 error) *MockOps_LoadWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_LoadWorkflow_Call) RunAndReturn(run func(context.Context, *model.Workflow) (string, error)) *MockOps_LoadWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function with given fields: ctx, req
func (_m *MockOps) Log(ctx context.Context, req *model.LogRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Log")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.LogRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type MockOps_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
//   - ctx context.Context
//   - req *model.LogRequest
func (_e *MockOps_Expecter) Log(ctx interface{}, req interface{}) *MockOps_Log_Call {
	return &MockOps_Log_Call{Call: _e.mock.On("Log", ctx, req)}
}

func (_c *MockOps_Log_Call) Run(run func(ctx context.Context, req *model.LogRequest)) *MockOps_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.LogRequest))
	})
	return _c
}

func (_c *MockOps_Log_Call) Return(_a0 error) *MockOps_Log_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_Log_Call) RunAndReturn(run func(context.Context, *model.LogRequest) error) *MockOps_Log_Call {
	_c.Call.Return(run)
	return _c
}

// OwnerID provides a mock function with given fields: ctx, name
func (_m *MockOps) OwnerID(ctx context.Context, name string) (string, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for OwnerID")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_OwnerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OwnerID'
type MockOps_OwnerID_Call struct {
	*mock.Call
}

// OwnerID is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockOps_Expecter) OwnerID(ctx interface{}, name interface{}) *MockOps_OwnerID_Call {
	return &MockOps_OwnerID_Call{Call: _e.mock.On("OwnerID", ctx, name)}
}

func (_c *MockOps_OwnerID_Call) Run(run func(ctx context.Context, name string)) *MockOps_OwnerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_OwnerID_Call) Return(_a0 string, _a1 error) *MockOps_OwnerID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_OwnerID_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_OwnerID_Call {
	_c.Call.Return(run)
	return _c
}

// OwnerName provides a mock function with given fields: ctx, id
func (_m *MockOps) OwnerName(ctx context.Context, id string) (string, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for OwnerName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_OwnerName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OwnerName'
type MockOps_OwnerName_Call struct {
	*mock.Call
}

// OwnerName is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockOps_Expecter) OwnerName(ctx interface{}, id interface{}) *MockOps_OwnerName_Call {
	return &MockOps_OwnerName_Call{Call: _e.mock.On("OwnerName", ctx, id)}
}

func (_c *MockOps_OwnerName_Call) Run(run func(ctx context.Context, id string)) *MockOps_OwnerName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockOps_OwnerName_Call) Return(_a0 string, _a1 error) *MockOps_OwnerName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_OwnerName_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockOps_OwnerName_Call {
	_c.Call.Return(run)
	return _c
}

// PersistFatalError provides a mock function with given fields: ctx, fatalError
func (_m *MockOps) PersistFatalError(ctx context.Context, fatalError *model.FatalError) (bool, error) {
	ret := _m.Called(ctx, fatalError)

	if len(ret) == 0 {
		panic("no return value specified for PersistFatalError")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.FatalError) (bool, error)); ok {
		return rf(ctx, fatalError)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.FatalError) bool); ok {
		r0 = rf(ctx, fatalError)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.FatalError) error); ok {
		r1 = rf(ctx, fatalError)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_PersistFatalError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PersistFatalError'
type MockOps_PersistFatalError_Call struct {
	*mock.Call
}

// PersistFatalError is a helper method to define mock.On call
//   - ctx context.Context
//   - fatalError *model.FatalError
func (_e *MockOps_Expecter) PersistFatalError(ctx interface{}, fatalError interface{}) *MockOps_PersistFatalError_Call {
	return &MockOps_PersistFatalError_Call{Call: _e.mock.On("PersistFatalError", ctx, fatalError)}
}

func (_c *MockOps_PersistFatalError_Call) Run(run func(ctx context.Context, fatalError *model.FatalError)) *MockOps_PersistFatalError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.FatalError))
	})
	return _c
}

func (_c *MockOps_PersistFatalError_Call) Return(_a0 bool, _a1 error) *MockOps_PersistFatalError_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_PersistFatalError_Call) RunAndReturn(run func(context.Context, *model.FatalError) (bool, error)) *MockOps_PersistFatalError_Call {
	_c.Call.Return(run)
	return _c
}

// ProcessServiceTasks provides a mock function with given fields: ctx, wf, svcTaskConsFn, wfProcessMappingFn
func (_m *MockOps) ProcessServiceTasks(ctx context.Context, wf *model.Workflow, svcTaskConsFn ServiceTaskConsumerFn, wfProcessMappingFn WorkflowProcessMappingFn) error {
	ret := _m.Called(ctx, wf, svcTaskConsFn, wfProcessMappingFn)

	if len(ret) == 0 {
		panic("no return value specified for ProcessServiceTasks")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow, ServiceTaskConsumerFn, WorkflowProcessMappingFn) error); ok {
		r0 = rf(ctx, wf, svcTaskConsFn, wfProcessMappingFn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_ProcessServiceTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessServiceTasks'
type MockOps_ProcessServiceTasks_Call struct {
	*mock.Call
}

// ProcessServiceTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - wf *model.Workflow
//   - svcTaskConsFn ServiceTaskConsumerFn
//   - wfProcessMappingFn WorkflowProcessMappingFn
func (_e *MockOps_Expecter) ProcessServiceTasks(ctx interface{}, wf interface{}, svcTaskConsFn interface{}, wfProcessMappingFn interface{}) *MockOps_ProcessServiceTasks_Call {
	return &MockOps_ProcessServiceTasks_Call{Call: _e.mock.On("ProcessServiceTasks", ctx, wf, svcTaskConsFn, wfProcessMappingFn)}
}

func (_c *MockOps_ProcessServiceTasks_Call) Run(run func(ctx context.Context, wf *model.Workflow, svcTaskConsFn ServiceTaskConsumerFn, wfProcessMappingFn WorkflowProcessMappingFn)) *MockOps_ProcessServiceTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Workflow), args[2].(ServiceTaskConsumerFn), args[3].(WorkflowProcessMappingFn))
	})
	return _c
}

func (_c *MockOps_ProcessServiceTasks_Call) Return(_a0 error) *MockOps_ProcessServiceTasks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_ProcessServiceTasks_Call) RunAndReturn(run func(context.Context, *model.Workflow, ServiceTaskConsumerFn, WorkflowProcessMappingFn) error) *MockOps_ProcessServiceTasks_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: ctx, subject, sharMsg
func (_m *MockOps) PublishMsg(ctx context.Context, subject string, sharMsg protoreflect.ProtoMessage) error {
	ret := _m.Called(ctx, subject, sharMsg)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsg")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, protoreflect.ProtoMessage) error); ok {
		r0 = rf(ctx, subject, sharMsg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type MockOps_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - sharMsg protoreflect.ProtoMessage
func (_e *MockOps_Expecter) PublishMsg(ctx interface{}, subject interface{}, sharMsg interface{}) *MockOps_PublishMsg_Call {
	return &MockOps_PublishMsg_Call{Call: _e.mock.On("PublishMsg", ctx, subject, sharMsg)}
}

func (_c *MockOps_PublishMsg_Call) Run(run func(ctx context.Context, subject string, sharMsg protoreflect.ProtoMessage)) *MockOps_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(protoreflect.ProtoMessage))
	})
	return _c
}

func (_c *MockOps_PublishMsg_Call) Return(_a0 error) *MockOps_PublishMsg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_PublishMsg_Call) RunAndReturn(run func(context.Context, string, protoreflect.ProtoMessage) error) *MockOps_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishWorkflowState provides a mock function with given fields: ctx, stateName, state, opts
func (_m *MockOps) PublishWorkflowState(ctx context.Context, stateName string, state *model.WorkflowState, opts ...PublishOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stateName, state)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishWorkflowState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.WorkflowState, ...PublishOpt) error); ok {
		r0 = rf(ctx, stateName, state, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_PublishWorkflowState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishWorkflowState'
type MockOps_PublishWorkflowState_Call struct {
	*mock.Call
}

// PublishWorkflowState is a helper method to define mock.On call
//   - ctx context.Context
//   - stateName string
//   - state *model.WorkflowState
//   - opts ...PublishOpt
func (_e *MockOps_Expecter) PublishWorkflowState(ctx interface{}, stateName interface{}, state interface{}, opts ...interface{}) *MockOps_PublishWorkflowState_Call {
	return &MockOps_PublishWorkflowState_Call{Call: _e.mock.On("PublishWorkflowState",
		append([]interface{}{ctx, stateName, state}, opts...)...)}
}

func (_c *MockOps_PublishWorkflowState_Call) Run(run func(ctx context.Context, stateName string, state *model.WorkflowState, opts ...PublishOpt)) *MockOps_PublishWorkflowState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]PublishOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*model.WorkflowState), variadicArgs...)
	})
	return _c
}

func (_c *MockOps_PublishWorkflowState_Call) Return(_a0 error) *MockOps_PublishWorkflowState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_PublishWorkflowState_Call) RunAndReturn(run func(context.Context, string, *model.WorkflowState, ...PublishOpt) error) *MockOps_PublishWorkflowState_Call {
	_c.Call.Return(run)
	return _c
}

// PutTaskSpec provides a mock function with given fields: ctx, spec
func (_m *MockOps) PutTaskSpec(ctx context.Context, spec *model.TaskSpec) (string, error) {
	ret := _m.Called(ctx, spec)

	if len(ret) == 0 {
		panic("no return value specified for PutTaskSpec")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.TaskSpec) (string, error)); ok {
		return rf(ctx, spec)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.TaskSpec) string); ok {
		r0 = rf(ctx, spec)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.TaskSpec) error); ok {
		r1 = rf(ctx, spec)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_PutTaskSpec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutTaskSpec'
type MockOps_PutTaskSpec_Call struct {
	*mock.Call
}

// PutTaskSpec is a helper method to define mock.On call
//   - ctx context.Context
//   - spec *model.TaskSpec
func (_e *MockOps_Expecter) PutTaskSpec(ctx interface{}, spec interface{}) *MockOps_PutTaskSpec_Call {
	return &MockOps_PutTaskSpec_Call{Call: _e.mock.On("PutTaskSpec", ctx, spec)}
}

func (_c *MockOps_PutTaskSpec_Call) Run(run func(ctx context.Context, spec *model.TaskSpec)) *MockOps_PutTaskSpec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.TaskSpec))
	})
	return _c
}

func (_c *MockOps_PutTaskSpec_Call) Return(_a0 string, _a1 error) *MockOps_PutTaskSpec_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_PutTaskSpec_Call) RunAndReturn(run func(context.Context, *model.TaskSpec) (string, error)) *MockOps_PutTaskSpec_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistory provides a mock function with given fields: ctx, state, historyType
func (_m *MockOps) RecordHistory(ctx context.Context, state *model.WorkflowState, historyType model.ProcessHistoryType) error {
	ret := _m.Called(ctx, state, historyType)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, model.ProcessHistoryType) error); ok {
		r0 = rf(ctx, state, historyType)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistory'
type MockOps_RecordHistory_Call struct {
	*mock.Call
}

// RecordHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
//   - historyType model.ProcessHistoryType
func (_e *MockOps_Expecter) RecordHistory(ctx interface{}, state interface{}, historyType interface{}) *MockOps_RecordHistory_Call {
	return &MockOps_RecordHistory_Call{Call: _e.mock.On("RecordHistory", ctx, state, historyType)}
}

func (_c *MockOps_RecordHistory_Call) Run(run func(ctx context.Context, state *model.WorkflowState, historyType model.ProcessHistoryType)) *MockOps_RecordHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].(model.ProcessHistoryType))
	})
	return _c
}

func (_c *MockOps_RecordHistory_Call) Return(_a0 error) *MockOps_RecordHistory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistory_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, model.ProcessHistoryType) error) *MockOps_RecordHistory_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryActivityComplete provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryActivityComplete(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryActivityComplete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryActivityComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryActivityComplete'
type MockOps_RecordHistoryActivityComplete_Call struct {
	*mock.Call
}

// RecordHistoryActivityComplete is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryActivityComplete(ctx interface{}, state interface{}) *MockOps_RecordHistoryActivityComplete_Call {
	return &MockOps_RecordHistoryActivityComplete_Call{Call: _e.mock.On("RecordHistoryActivityComplete", ctx, state)}
}

func (_c *MockOps_RecordHistoryActivityComplete_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryActivityComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryActivityComplete_Call) Return(_a0 error) *MockOps_RecordHistoryActivityComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryActivityComplete_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryActivityComplete_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryActivityExecute provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryActivityExecute(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryActivityExecute")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryActivityExecute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryActivityExecute'
type MockOps_RecordHistoryActivityExecute_Call struct {
	*mock.Call
}

// RecordHistoryActivityExecute is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryActivityExecute(ctx interface{}, state interface{}) *MockOps_RecordHistoryActivityExecute_Call {
	return &MockOps_RecordHistoryActivityExecute_Call{Call: _e.mock.On("RecordHistoryActivityExecute", ctx, state)}
}

func (_c *MockOps_RecordHistoryActivityExecute_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryActivityExecute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryActivityExecute_Call) Return(_a0 error) *MockOps_RecordHistoryActivityExecute_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryActivityExecute_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryActivityExecute_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryCompensationCheckpoint provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryCompensationCheckpoint(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryCompensationCheckpoint")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryCompensationCheckpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryCompensationCheckpoint'
type MockOps_RecordHistoryCompensationCheckpoint_Call struct {
	*mock.Call
}

// RecordHistoryCompensationCheckpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryCompensationCheckpoint(ctx interface{}, state interface{}) *MockOps_RecordHistoryCompensationCheckpoint_Call {
	return &MockOps_RecordHistoryCompensationCheckpoint_Call{Call: _e.mock.On("RecordHistoryCompensationCheckpoint", ctx, state)}
}

func (_c *MockOps_RecordHistoryCompensationCheckpoint_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryCompensationCheckpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryCompensationCheckpoint_Call) Return(_a0 error) *MockOps_RecordHistoryCompensationCheckpoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryCompensationCheckpoint_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryCompensationCheckpoint_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryJobAbort provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryJobAbort(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryJobAbort")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryJobAbort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryJobAbort'
type MockOps_RecordHistoryJobAbort_Call struct {
	*mock.Call
}

// RecordHistoryJobAbort is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryJobAbort(ctx interface{}, state interface{}) *MockOps_RecordHistoryJobAbort_Call {
	return &MockOps_RecordHistoryJobAbort_Call{Call: _e.mock.On("RecordHistoryJobAbort", ctx, state)}
}

func (_c *MockOps_RecordHistoryJobAbort_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryJobAbort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryJobAbort_Call) Return(_a0 error) *MockOps_RecordHistoryJobAbort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryJobAbort_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryJobAbort_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryJobComplete provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryJobComplete(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryJobComplete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryJobComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryJobComplete'
type MockOps_RecordHistoryJobComplete_Call struct {
	*mock.Call
}

// RecordHistoryJobComplete is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryJobComplete(ctx interface{}, state interface{}) *MockOps_RecordHistoryJobComplete_Call {
	return &MockOps_RecordHistoryJobComplete_Call{Call: _e.mock.On("RecordHistoryJobComplete", ctx, state)}
}

func (_c *MockOps_RecordHistoryJobComplete_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryJobComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryJobComplete_Call) Return(_a0 error) *MockOps_RecordHistoryJobComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryJobComplete_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryJobComplete_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryJobExecute provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryJobExecute(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryJobExecute")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryJobExecute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryJobExecute'
type MockOps_RecordHistoryJobExecute_Call struct {
	*mock.Call
}

// RecordHistoryJobExecute is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryJobExecute(ctx interface{}, state interface{}) *MockOps_RecordHistoryJobExecute_Call {
	return &MockOps_RecordHistoryJobExecute_Call{Call: _e.mock.On("RecordHistoryJobExecute", ctx, state)}
}

func (_c *MockOps_RecordHistoryJobExecute_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryJobExecute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryJobExecute_Call) Return(_a0 error) *MockOps_RecordHistoryJobExecute_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryJobExecute_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryJobExecute_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryProcessAbort provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryProcessAbort(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryProcessAbort")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryProcessAbort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryProcessAbort'
type MockOps_RecordHistoryProcessAbort_Call struct {
	*mock.Call
}

// RecordHistoryProcessAbort is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryProcessAbort(ctx interface{}, state interface{}) *MockOps_RecordHistoryProcessAbort_Call {
	return &MockOps_RecordHistoryProcessAbort_Call{Call: _e.mock.On("RecordHistoryProcessAbort", ctx, state)}
}

func (_c *MockOps_RecordHistoryProcessAbort_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryProcessAbort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryProcessAbort_Call) Return(_a0 error) *MockOps_RecordHistoryProcessAbort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryProcessAbort_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryProcessAbort_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryProcessComplete provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryProcessComplete(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryProcessComplete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryProcessComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryProcessComplete'
type MockOps_RecordHistoryProcessComplete_Call struct {
	*mock.Call
}

// RecordHistoryProcessComplete is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryProcessComplete(ctx interface{}, state interface{}) *MockOps_RecordHistoryProcessComplete_Call {
	return &MockOps_RecordHistoryProcessComplete_Call{Call: _e.mock.On("RecordHistoryProcessComplete", ctx, state)}
}

func (_c *MockOps_RecordHistoryProcessComplete_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryProcessComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryProcessComplete_Call) Return(_a0 error) *MockOps_RecordHistoryProcessComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryProcessComplete_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryProcessComplete_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryProcessSpawn provides a mock function with given fields: ctx, state, newProcessInstanceID
func (_m *MockOps) RecordHistoryProcessSpawn(ctx context.Context, state *model.WorkflowState, newProcessInstanceID string) error {
	ret := _m.Called(ctx, state, newProcessInstanceID)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryProcessSpawn")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState, string) error); ok {
		r0 = rf(ctx, state, newProcessInstanceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryProcessSpawn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryProcessSpawn'
type MockOps_RecordHistoryProcessSpawn_Call struct {
	*mock.Call
}

// RecordHistoryProcessSpawn is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
//   - newProcessInstanceID string
func (_e *MockOps_Expecter) RecordHistoryProcessSpawn(ctx interface{}, state interface{}, newProcessInstanceID interface{}) *MockOps_RecordHistoryProcessSpawn_Call {
	return &MockOps_RecordHistoryProcessSpawn_Call{Call: _e.mock.On("RecordHistoryProcessSpawn", ctx, state, newProcessInstanceID)}
}

func (_c *MockOps_RecordHistoryProcessSpawn_Call) Run(run func(ctx context.Context, state *model.WorkflowState, newProcessInstanceID string)) *MockOps_RecordHistoryProcessSpawn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].(string))
	})
	return _c
}

func (_c *MockOps_RecordHistoryProcessSpawn_Call) Return(_a0 error) *MockOps_RecordHistoryProcessSpawn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryProcessSpawn_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, string) error) *MockOps_RecordHistoryProcessSpawn_Call {
	_c.Call.Return(run)
	return _c
}

// RecordHistoryProcessStart provides a mock function with given fields: ctx, state
func (_m *MockOps) RecordHistoryProcessStart(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RecordHistoryProcessStart")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RecordHistoryProcessStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordHistoryProcessStart'
type MockOps_RecordHistoryProcessStart_Call struct {
	*mock.Call
}

// RecordHistoryProcessStart is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RecordHistoryProcessStart(ctx interface{}, state interface{}) *MockOps_RecordHistoryProcessStart_Call {
	return &MockOps_RecordHistoryProcessStart_Call{Call: _e.mock.On("RecordHistoryProcessStart", ctx, state)}
}

func (_c *MockOps_RecordHistoryProcessStart_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RecordHistoryProcessStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RecordHistoryProcessStart_Call) Return(_a0 error) *MockOps_RecordHistoryProcessStart_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RecordHistoryProcessStart_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RecordHistoryProcessStart_Call {
	_c.Call.Return(run)
	return _c
}

// RetryActivity provides a mock function with given fields: ctx, state
func (_m *MockOps) RetryActivity(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for RetryActivity")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_RetryActivity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryActivity'
type MockOps_RetryActivity_Call struct {
	*mock.Call
}

// RetryActivity is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) RetryActivity(ctx interface{}, state interface{}) *MockOps_RetryActivity_Call {
	return &MockOps_RetryActivity_Call{Call: _e.mock.On("RetryActivity", ctx, state)}
}

func (_c *MockOps_RetryActivity_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_RetryActivity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_RetryActivity_Call) Return(_a0 error) *MockOps_RetryActivity_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_RetryActivity_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_RetryActivity_Call {
	_c.Call.Return(run)
	return _c
}

// SignalFatalErrorPause provides a mock function with given fields: ctx, state, log
func (_m *MockOps) SignalFatalErrorPause(ctx context.Context, state *model.WorkflowState, log *slog.Logger) {
	_m.Called(ctx, state, log)
}

// MockOps_SignalFatalErrorPause_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignalFatalErrorPause'
type MockOps_SignalFatalErrorPause_Call struct {
	*mock.Call
}

// SignalFatalErrorPause is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
//   - log *slog.Logger
func (_e *MockOps_Expecter) SignalFatalErrorPause(ctx interface{}, state interface{}, log interface{}) *MockOps_SignalFatalErrorPause_Call {
	return &MockOps_SignalFatalErrorPause_Call{Call: _e.mock.On("SignalFatalErrorPause", ctx, state, log)}
}

func (_c *MockOps_SignalFatalErrorPause_Call) Run(run func(ctx context.Context, state *model.WorkflowState, log *slog.Logger)) *MockOps_SignalFatalErrorPause_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].(*slog.Logger))
	})
	return _c
}

func (_c *MockOps_SignalFatalErrorPause_Call) Return() *MockOps_SignalFatalErrorPause_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_SignalFatalErrorPause_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, *slog.Logger)) *MockOps_SignalFatalErrorPause_Call {
	_c.Call.Return(run)
	return _c
}

// SignalFatalErrorTeardown provides a mock function with given fields: ctx, state, log
func (_m *MockOps) SignalFatalErrorTeardown(ctx context.Context, state *model.WorkflowState, log *slog.Logger) {
	_m.Called(ctx, state, log)
}

// MockOps_SignalFatalErrorTeardown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignalFatalErrorTeardown'
type MockOps_SignalFatalErrorTeardown_Call struct {
	*mock.Call
}

// SignalFatalErrorTeardown is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
//   - log *slog.Logger
func (_e *MockOps_Expecter) SignalFatalErrorTeardown(ctx interface{}, state interface{}, log interface{}) *MockOps_SignalFatalErrorTeardown_Call {
	return &MockOps_SignalFatalErrorTeardown_Call{Call: _e.mock.On("SignalFatalErrorTeardown", ctx, state, log)}
}

func (_c *MockOps_SignalFatalErrorTeardown_Call) Run(run func(ctx context.Context, state *model.WorkflowState, log *slog.Logger)) *MockOps_SignalFatalErrorTeardown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState), args[2].(*slog.Logger))
	})
	return _c
}

func (_c *MockOps_SignalFatalErrorTeardown_Call) Return() *MockOps_SignalFatalErrorTeardown_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOps_SignalFatalErrorTeardown_Call) RunAndReturn(run func(context.Context, *model.WorkflowState, *slog.Logger)) *MockOps_SignalFatalErrorTeardown_Call {
	_c.Call.Return(run)
	return _c
}

// StartJob provides a mock function with given fields: ctx, subject, job, el, v, opts
func (_m *MockOps) StartJob(ctx context.Context, subject string, job *model.WorkflowState, el *model.Element, v []byte, opts ...PublishOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, subject, job, el, v)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.WorkflowState, *model.Element, []byte, ...PublishOpt) error); ok {
		r0 = rf(ctx, subject, job, el, v, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_StartJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartJob'
type MockOps_StartJob_Call struct {
	*mock.Call
}

// StartJob is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - job *model.WorkflowState
//   - el *model.Element
//   - v []byte
//   - opts ...PublishOpt
func (_e *MockOps_Expecter) StartJob(ctx interface{}, subject interface{}, job interface{}, el interface{}, v interface{}, opts ...interface{}) *MockOps_StartJob_Call {
	return &MockOps_StartJob_Call{Call: _e.mock.On("StartJob",
		append([]interface{}{ctx, subject, job, el, v}, opts...)...)}
}

func (_c *MockOps_StartJob_Call) Run(run func(ctx context.Context, subject string, job *model.WorkflowState, el *model.Element, v []byte, opts ...PublishOpt)) *MockOps_StartJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]PublishOpt, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*model.WorkflowState), args[3].(*model.Element), args[4].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *MockOps_StartJob_Call) Return(_a0 error) *MockOps_StartJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_StartJob_Call) RunAndReturn(run func(context.Context, string, *model.WorkflowState, *model.Element, []byte, ...PublishOpt) error) *MockOps_StartJob_Call {
	_c.Call.Return(run)
	return _c
}

// StoreWorkflow provides a mock function with given fields: ctx, wf
func (_m *MockOps) StoreWorkflow(ctx context.Context, wf *model.Workflow) (string, error) {
	ret := _m.Called(ctx, wf)

	if len(ret) == 0 {
		panic("no return value specified for StoreWorkflow")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow) (string, error)); ok {
		return rf(ctx, wf)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.Workflow) string); ok {
		r0 = rf(ctx, wf)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.Workflow) error); ok {
		r1 = rf(ctx, wf)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_StoreWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreWorkflow'
type MockOps_StoreWorkflow_Call struct {
	*mock.Call
}

// StoreWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - wf *model.Workflow
func (_e *MockOps_Expecter) StoreWorkflow(ctx interface{}, wf interface{}) *MockOps_StoreWorkflow_Call {
	return &MockOps_StoreWorkflow_Call{Call: _e.mock.On("StoreWorkflow", ctx, wf)}
}

func (_c *MockOps_StoreWorkflow_Call) Run(run func(ctx context.Context, wf *model.Workflow)) *MockOps_StoreWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Workflow))
	})
	return _c
}

func (_c *MockOps_StoreWorkflow_Call) Return(_a0 string, _a1 error) *MockOps_StoreWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_StoreWorkflow_Call) RunAndReturn(run func(context.Context, *model.Workflow) (string, error)) *MockOps_StoreWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// TearDownWorkflow provides a mock function with given fields: ctx, state
func (_m *MockOps) TearDownWorkflow(ctx context.Context, state *model.WorkflowState) (bool, error) {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for TearDownWorkflow")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) (bool, error)); ok {
		return rf(ctx, state)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) bool); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *model.WorkflowState) error); ok {
		r1 = rf(ctx, state)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOps_TearDownWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TearDownWorkflow'
type MockOps_TearDownWorkflow_Call struct {
	*mock.Call
}

// TearDownWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) TearDownWorkflow(ctx interface{}, state interface{}) *MockOps_TearDownWorkflow_Call {
	return &MockOps_TearDownWorkflow_Call{Call: _e.mock.On("TearDownWorkflow", ctx, state)}
}

func (_c *MockOps_TearDownWorkflow_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_TearDownWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_TearDownWorkflow_Call) Return(_a0 bool, _a1 error) *MockOps_TearDownWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOps_TearDownWorkflow_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) (bool, error)) *MockOps_TearDownWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// XDestroyProcessInstance provides a mock function with given fields: ctx, state
func (_m *MockOps) XDestroyProcessInstance(ctx context.Context, state *model.WorkflowState) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for XDestroyProcessInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *model.WorkflowState) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockOps_XDestroyProcessInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XDestroyProcessInstance'
type MockOps_XDestroyProcessInstance_Call struct {
	*mock.Call
}

// XDestroyProcessInstance is a helper method to define mock.On call
//   - ctx context.Context
//   - state *model.WorkflowState
func (_e *MockOps_Expecter) XDestroyProcessInstance(ctx interface{}, state interface{}) *MockOps_XDestroyProcessInstance_Call {
	return &MockOps_XDestroyProcessInstance_Call{Call: _e.mock.On("XDestroyProcessInstance", ctx, state)}
}

func (_c *MockOps_XDestroyProcessInstance_Call) Run(run func(ctx context.Context, state *model.WorkflowState)) *MockOps_XDestroyProcessInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.WorkflowState))
	})
	return _c
}

func (_c *MockOps_XDestroyProcessInstance_Call) Return(_a0 error) *MockOps_XDestroyProcessInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockOps_XDestroyProcessInstance_Call) RunAndReturn(run func(context.Context, *model.WorkflowState) error) *MockOps_XDestroyProcessInstance_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOps creates a new instance of MockOps. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOps(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOps {
	mock := &MockOps{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
